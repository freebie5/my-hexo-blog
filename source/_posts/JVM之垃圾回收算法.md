---
title: JVM之垃圾回收算法
date: 2020-08-10 22:47:40
tags: 
- JVM
- 垃圾回收算法
categories: JVM相关
---

JVM运行时数据区分为5部分，其中**程序计数器**，**Java虚拟机栈**，**本地方法栈**这3个运行时数据区随线程而生，随线程而灭，线程结束时内存就被回收了。

剩下**Java堆**，**方法区**这2个运行时数据区，他们内存分配和回收都是动态的。

## 1.如何判断对象是否活着

### 1.1引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；用对象计数器是否为0来判断对象是否可被回收。

缺点：对象之间相互循环引用，如下代码所示，a和b相互循环引用了，因此，没有被主流JVM采用。

```java
public class ReferenceCountingGC {

    public Object instance;

    public ReferenceCountingGC(String name) {
    }

    public static void main(String[] args) {

        ReferenceCountingGC a = new ReferenceCountingGC("objA");
        ReferenceCountingGC b = new ReferenceCountingGC("objB");

        // a和b互相引用了
        a.instance = b;
        b.instance = a;

        a = null;
        b = null;
    }

}
```

### 1.2.可达性分析算法

通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

<p><img src="/assets/blogImg/JVM之垃圾回收算法_01.png" width="600"></p>

如上图所示，，对象object5，object6，object7虽然相互关联，但是他们到GC Roots是不可达的，所以他们被判定为可回收对象。

GC Roots包括下面4种：

1）虚拟机栈（栈帧中的局部变量表）中引用的对象；

2）方法区中类静态属性引用的对象；

3）方法区中常量引用的对象；

4）本地方法栈中JNI（native修饰的方法）引用的对象。

## 2.垃圾回收算法

通过可达性分析算法，我们可以知道哪些对象可以被回收，下面介绍3种回收对象的算法

### 2.1.标记-清除算法

算法分为“标记”和“清除”两个阶段，首先标记出所有可以回收的对象，然后标记完成后统一回收所有被标记的对象。

缺点：

1）效率问题，标记和清除两个过程的效率都不高；

2）空间问题，标记清除后产生大量不连续的内存碎片。如果空间碎片太多，当需要分配较大对象时，就会找不到连续内存进行分配。

<p><img src="/assets/blogImg/JVM之垃圾回收算法_02.png" width="600"></p>

### 2.2.复制算法

算法将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还活着的对象复制到另外一块上面，然后再把已经使用的内存空间一次清理掉。

缺点：

1）将内存容量缩小为原来的一半，内存容量利用率不高；

2）如果不想浪费一半的内存容量，就需要老年代进行**分配担保（Handle Promotion）**。

<p><img src="/assets/blogImg/JVM之垃圾回收算法_03.png" width="600"></p>

### 2.3.标记-整理算法

算法分为“标记”和“整理”两个阶段，首先标记所有存活的对象，然后将所有存货的对象都向一端移动，最后清理掉边界以外的内存。

<p><img src="/assets/blogImg/JVM之垃圾回收算法_04.png" width="600"></p>

### 2.4.分代收集算法

根据对象存活周期的不同将内存划分为几块。一般把Java堆分为**新生代**和**老年代**。

在新生代中，每次垃圾收集时都发现大批对象死去，只要少量存活，那就选用复制算法；

在老年代中，对象存活率高，没有额外空间进行分配担保，一般使用**标记-清除**或者**标记-整理**进行回收。

## 3.拓展

### 3.1.判断对象可回收的流程

判断一个对象可回收需要2次标记过程：

1）如果对象在进行可达性分析后发现没有与GC Roots相连接的**引用链**，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法或者finalize已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”；

2）如果这个对象被判定为有必要执行，那么这个对象将被放置在F-Queue队列之中，并在稍后由虚拟机的Finalizer线程去执行这个对象的finalize方法；

3）如果对象要在finalize方法中拯救自己，只需要把自己与**引用链**的任何一个对象建立关联即可；

4）GC线程将对F-Queue队列中的对象进行第二次小规模的标记，如果对象拯救了自己，则被移除F-Queue队列；否则，对象被第二次标记，那么对象就会被回收。

### 3.2.回收方法区

方法区垃圾回收主要分为两部分：

1）废弃常量；

2）无用的类。

## 4.引用

《深入理解Java虚拟机》 周志明

https://mp.weixin.qq.com/s/INAFTkNxOiM76fzAs38TOg