---
title: 《深入理解Java虚拟机》线程安全与锁优化
date: 2020-11-14 15:27:50
tags: 
- JVM
- 线程安全
- 锁优化
categories: 读书笔记
---

## 线程安全

《Java Concurrency In Practice》的作者Brain Goetz对**线程安全**有一个比较恰当的定义：

当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的**调度**和**交替执行**，也不需要进行**额外的同步**，或者在调用方进行任何其他的**协调操作**，**调用这个对象的行为**都可以获得正确的结果，那这个**对象是线程安全的**。

要达到这个定义的要求比较难，一般把**调用这个对象的行为**改为**单次调用**，其他描述也成立的话，我们就可以称这个**对象是线程安全的**。

### Java语言的线程安全

在Java语言中，按照线程安全的**安全程度**由强至弱分为5类：

1）不可变；2）绝对线程安全；3）相对线程安全；4）线程兼容；5）线程对立

#### 不可变

Java语言中**不可变（Immutable）**的对象一定是线程安全的。无论是对象的方法实现还是方法的调用者，都不需要采取任何的线程安全保障措施。

常见的不可变对象有：String实例，枚举类实例，Integer实例，Long实例

#### 绝对线程安全

绝对线程安全完全满足Brain Goetz的线程安全定义，这个定义其实很严格，需要付出很大的代价。

#### 相对线程安全

相对线程安全就是我们通常说的线程安全。需要保证对这个对象单独的操作是线程安全的，我们调用的时候不需要额外的保障措施，但是对于一些特定顺序的连续调用，可能需要在调用端使用额外的同步锁手段来保证正确性。

常见的相对线程安全对象有：Vector，Hashtable，Collections#synchronizedCollection方法封装的集合实例

#### 线程兼容

线程兼容指对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象线程安全。

我常说一个类不是线程安全，指的就是这种情况。

常见的线程兼容对象有：ArrayList，HashMap

#### 线程对立

线程对立指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

Java语言很少出现这个情况，但是有个例子：

Thread类的**suspend**方法和**resume**方法，如果有两个线程同时持有同一个Thread对象，如果并发执行，一个执行suspend，一个执行resume，无论调用端是否进行了同步措施，都存在死锁风险。

### 线程安全的实现方法

#### 互斥同步

同步指在多个线程并发访问共享数据时，保证在同一时刻只被一个线程使用。

互斥是实现同步的一种手段，Java语言中可以使用synchronized关键字和ReentrantLock。

#### 非阻塞同步

CAS+自旋

java语言中的Unsafe类

#### 无同步方案

可重入代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的线程不会出现任何错误。

线程本地存储，java语言中的ThreadLocal类

## 锁优化

### 自旋锁

互斥同步通过阻塞实现，挂起和恢复线程需要转入内核态中完成，性能消耗很大。

如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求的那个线程执行一个**忙循环（自旋）**，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，这项技术就是**自旋锁**。

如果锁被占用的时间很短，自旋效果就会很好；如果锁被占用时间长，那么自旋会消耗处理器资源。

自旋的次数有限制（默认10次），如果超过限制仍然没有获得锁，就应该挂起线程，进行阻塞。

### 自适应自旋

自适应指自旋次数不是固定的，由前一次在同一个锁上的自旋次数决定。

如果在同一个锁对象上，自旋等待各个成功获取过锁，那么这次自旋也很有可能再次成功，那么这次的自旋次数会增加，比如100次；

如果对于某个锁，自旋很少成功获得过锁，那么获取这个锁的时候，可能会省略自旋过程，直接挂起线程。

### 锁消除

锁消除指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

例如，下面的代码

```java
public String concat(String a, String b, String c) {
    return a + b + c;
}
```

在javac编译后会转化为下面的代码

```java
public String concat(String a, String b, String c) {
	StringBuffer sb = new StringBuffer();
    sb.append(a);
    sb.append(b);
    sb.append(c);
    return sb.toString();
}
```

我们知道StringBuffer#append方法被synchronized修饰，但是sb对象是个局部变量，这里每个append方法都加锁就没有意义，这种情况的锁会被消除

### 锁粗化

还是上面的append方法，如果虚拟机探测到有一串零碎的操作都是对一个对象加锁，将会把加锁同步的范围粗化到整个操作序列的外部，例如第一个append方法前面和最后一个append方法后面，这样加一次锁就可以了。

### *轻量级锁

轻量级锁是JDK1.6加入的新型锁机制，轻量级是相较于挂起线程的传统锁而言的，传统锁也叫**重量级锁**。

**轻量级锁执行过程：**

在代码进入同步块的时候，如果此锁对象没有被锁定（锁标志位是01），虚拟机首先在当前线程的**栈帧**中建立一个**锁记录（Lock Record）**的空间，用来存储**锁对象的Mark Word**。

然后，虚拟机使用CAS尝试将锁对象的Mark Word更新为指向当前线程栈帧的Lock Record的指针。

如果更新成功，那么线程就拥有了改对象的锁，并且锁对象的Mark Word的锁标志位变为00。

如果更新失败，虚拟机将会检查锁对象的Mark Word是否为指向当前线程栈帧的Lock Record的指针。

如果是，说明当前线程已经拥有了这个锁对象，那就可以进入同步块继续执行。

如果不是，说明这个锁对象已经被其他线程抢占了。

如果有两个以上的线程争抢同一个锁对象，那么轻量级锁机制不在有效，膨胀为重量级锁，后面等待锁对象的线程进入阻塞。

### *偏向锁

偏向锁是JDK1.6引入的一项锁优化。轻量级锁是在无竞争的情况下使用CAS操作去消除阻塞挂起。偏向锁是在无竞争的情况下连CAS操作也不做了。

偏向锁的**偏**是偏心的意思，锁对象会偏向第一个获取到它的线程。

**偏向锁执行过程：**

当锁对象第一次被线程获取的时候，虚拟机把Mark Word的锁标志位变为01，同时使用CAS操作把获取到锁对象的线程的**线程ID**记录在锁对象的Mark Word中，如果成功，获取到锁对象的线程以后每次进入锁相关的同步块时，都不需要进行同步操作。

当有另外一个线程去尝试获取这个锁对象时，偏向锁模式就结束了。







