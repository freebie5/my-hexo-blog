---
title: Java并发机制的底层实现原理
date: 2020-08-22 00:05:56
tags: 
- volatile
- synchronized
- 原子操作
categories: 并发编程相关
---

首先明确一点，Java代码代编译后会变成**字节码**，字节码被**类加载器**加载到JVM里，JVM执行字节码，最终需要转化为**汇编指令**在CPU上执行。

Java的并发机制依赖于**JVM的实现**和**CPU的指令**。

Java的常用并发机制包括：1）volatile声明共享变量；2）synchronized修饰；3）原子操作。

## 1.volatile的实现原理

### volatile的作用：

volatile保证了多线程共享变量的**可见性**。

### volatile的实现原理：

1）如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条**Lock**前缀的指令，将这个变量所在**缓存行**的数据写回到系统内存。

2）在多处理器下，为了保证各个处理器的**缓存行**是一致的，就会实现**缓存一致性协议**。

### Tips

可见性：是指多线程环境下，当一个线程修改一个共享变量时，其他的线程能读取到这个修改的值。

缓存行（cache line）：缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。

**缓存一致性协议**：每个处理器通过嗅探在**总线上传播的数据**来检查自己缓存的值是不是过期了，当处理器发现自己**缓存行对应的内存地址**被修改，就会将当前处理器的缓存行设置成**无效状态**，当处理器对这个数据进行修改操作的时候，就会重新从**系统内存**中把数据读到处理器缓存里。

## 2.synchronized的实现原理

JDK1.6对synchronized进行了优化，引入了**偏向锁**，**轻量级锁**，**锁的存储结构**和**锁的升级过程**。

synchronized可以用于修饰以下3种情况：

1）对于对象同步方法，锁是当前对象；

2）对于类同步方法，锁是当前类的Class对象；

3）对于同步方法块，锁是synchronized括号里的对象或类。

### synchronized的实现原理

JVM基于进入和退出**Monitor对象**来实现**方法同步**和**代码块同步**，但两者实现细节不同。

方法同步：JVM规范没有详细说说明，可以和代码块同步实现一样。

代码块同步：使用**monitorenter**和**monitorexit**指令来实现。Java代码被编译成字节码后，在同步代码块开始位置插入monitorenter指令，在方法结束和异常处插入monitorexit指令。所有对象都有一个monitor与之关联，当monitor被一个线程持有后，monitor处于锁定状态，其他线程无法持有。线程执行到monitorenter指令时将尝试获取对象的monitor，只有获得对象的monitor后才能才能继续执行，当线程执行到monitorexit指令时将释放对象monitor，这时其他线程才能竞争获取。

### Java对象头和锁的升级过程

在Hot Spot虚拟机中，**对象在内存中存储的布局**可以分为3块区域：

1）**对象头（Header）**；2）**实例数据（Instance Data）**；3）**对齐填充（Padding）**。

**实例数据**是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

**对齐填充**没有特别的含义，它仅仅起着占位符的作用。由于Hot Spot要求对象的大小必须是8字节的整数倍，**对象头**正好是8字节的倍数，所以，当**实例数据**部分没有对齐时，就需要通过对齐填充来补全。

**对象头**包含几部分的数据：

如果对象是数组类型，则虚拟机用3个**字宽（Word）**存储对象头；

如果对象是非数组类型，则虚拟机用2个**字宽（Word）**存储对象头；

在32位虚拟机中，1字宽等于4字节，即32位；在64位虚拟机中，1字宽等于8字节，即64位。**对象头**存储内容如下表所示

| 长度      | 内容                   | 说明                                               |
| --------- | ---------------------- | -------------------------------------------------- |
| 32位/64位 | Mark Word              | 存储对象的hashCode或锁信息等                       |
| 32位/64位 | Class Metadata Address | 存储指向对象类型数据的指针                         |
| 32位/32位 | Array Length           | 如果对象是数组类型才会有这部分内容，存储数组的长度 |

**Mark Word**默认情况下，包含几部分数据：1）对象的hashCode；2）分代年龄；3）锁标记位。

32位JVM的Mark Word默认存储结构如下表所示

| 锁状态   | 25位           | 4位          | 1位是否是偏向锁 | 2位锁标志位 |
| -------- | -------------- | ------------ | --------------- | ----------- |
| 无锁状态 | 对象的hashCode | 对象分代年龄 | 0               | 01          |

在运行期间，Mark Word存储结构可能发生变化，变化为如下4种

| 锁状态 | 23位   | 2位   | 4位          | 1位  | 2位  |
| ------ | ------ | ----- | ------------ | ---- | ---- |
| 偏向锁 | 线程ID | epoch | 对象分代年龄 | 1    | 01   |

| 锁状态   | 30位                 | 2位  |
| -------- | -------------------- | ---- |
| 轻量级锁 | 指向栈中锁记录的指针 | 00   |

| 锁状态   | 30位                         | 2位  |
| -------- | ---------------------------- | ---- |
| 重量级锁 | 指向互斥量（重量级锁）的指针 | 10   |

| 锁状态 | 30位 | 2位  |
| ------ | ---- | ---- |
| GC标记 | 空   | 11   |

### 锁的升级

JDK1.6为了减少获得和释放锁带来的性能消耗，引入了**偏向锁**和**轻量级锁**。锁一共有4种状态，级别从低到高依次是：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态。**锁可以升级但不能降级**。

**偏向锁机制**

当一个线程访问同步块并获取锁时，会在**对象头**和**栈帧中的锁记录**存储**锁偏向的线程ID**，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。

**轻量级锁机制**

线程在执行同步块之前，JVM会先在**当前线程的栈帧**中创建用于存储**锁记录**的空间，并将**对象头Mark Word**复制到**锁记录**中，然后线程尝试使用CAS将对象头中的Mark Word替换为**指向锁记录的指针**。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用**自旋**来获取锁。

## 3.原子操作的实现原理

**原子操作**意为**不可被中断的一个或一系列操作**。

### CPU如何实现原子操作

CPU提供了2个机制来实现原子操作：1）总线锁定；2）缓存锁定。

**总线锁定**使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

**缓存锁定**指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。

针对以上2个机制，CPU提供了很多指令来实现，例如：XADD，CMPXCHG。JVM的**CAS操作**就是利用了CPU的CMPXCHG指令实现。