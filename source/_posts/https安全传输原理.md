---
title: https安全传输原理
date: 2020-08-20 23:57:48
tags: 
- https
- 对称加密
- 非对称加密
- 中间人攻击
- 数字签名
- 数字证书
categories: 网络相关
---

客户端和服务端如果使用http协议进行数据传输，数据内容没有加密，很容易泄漏。所以才有了后来的https协议。下面一步一步的说明https安全传输原理。

## 对称加密

什么是对称加密？简单理解就是加密和解密都是同一把密钥。

如果数据内容没有加密，我们直接使用**对称加密**对数据进行加密即可，但是对称加密密钥怎么让对方知道呢，如果通过网络传输，有可能被黑客拦截，这样黑客也知道了密钥，对称加密也就失效了。

## 非对称加密

非对称加密有两把密钥：

1）私钥：只有自己知道；

2）公钥：所有人都知道；

非对称加密有个特点：私钥加密的数据只有公钥可以解密，公钥加密的数据只有私钥可以解密。

客户端和服务端相互发送数据前，需要通过网络交换彼此的公钥，然后才开始相互发送数据。

客户端发送数据给服务端：

1）客户端使用服务端的公钥加密数据并发送给服务端；

2）服务端收到数据，使用服务端的私钥解密数据；

服务端发送数据给客户端：

1）服务端使用客户端的公钥加密数据并发送给客户端；

2）客户端收到数据，使用客户端的私钥解密数据；

这样，就算黑客知道客户端的公钥和服务端的公钥也解密不了数据。

## 非对称加密 + 对称加密

非对称加密相比于对称加密有个缺点，那就是加密解密效率比对称加密低。所以我们可以使用**非对称加密**来加密**对称加密**的密钥，然后使用对称加密的密钥加密数据。

客户端发送数据给服务端：

1）客户端使用服务端的公钥加密对称加密的密钥并发送给服务端；

2）服务端收到数据，使用服务端私钥解密数据，获得对称加密的密钥；

3）客户端使用对称加密的密钥加密数据并发送给服务端；

4）服务端收到数据，使用对称加密的密钥解密数据；

## 中间人攻击

虽然非对称加密可以解决对称加密的密钥通过网络传输被黑客拦截导致加密失效的问题，但是还是有漏洞。

如果客户端和服务端在相互交换公钥的过程中，黑客拦截了客户端的数据并替换**客户端公钥（ClientPublicKey，CPubKey）**为**黑客公钥（HackerPublicKey，HPubKey）**，这样服务端收到的公钥其实是黑客公钥。同理，黑客拦截服务端的数据并替换**服务端公钥（ServerPublicKey，SPubKey）**为黑客公钥，这样客户端收到的公钥其实是黑客公钥。

被黑客拦截并替换了公钥会有什么结果呢？

客户端发送数据给服务端：

1）客户端使用**HPubKey**加密数据并发送给服务端；

2）黑客拦截客户端的数据，使用**黑客私钥（HackerPrivateKey，HPriKey）**解密数据，这样数据泄漏了；

3）黑客使用**HPriKey**加密**步骤2）解密后的数据**，并发送给服务端；

4）服务端收到黑客的数据，使用**HPubKey**解密数据；

服务端发送数据给客户端：

1）服务端使用**HPubKey**加密数据并发送给客户端；

2）黑客拦截服务端的数据，使用**HPriKey**解密数据，这样数据泄漏了；

3）黑客使用**HPriKey**加密**步骤2）解密后的数据**，并发送给客户端；

4）客户端收到黑客的数据，使用**HPubKey**解密数据；

客户端和服务端相互发送数据的过程中并不知道数据已经泄漏了，而且持有的公钥都是黑客公钥。

## 数字签名

### 1.无法判断客户端公钥属于客户端

会受到中间人攻击的原因并不是公钥被黑客拦截泄漏，而是不能确认客户端的公钥属于客户端，服务端的公钥属于服务端。黑客拦截了客户端发送的客户端公钥，替换为黑客的公钥，服务端收到的公钥是黑客的公钥，而不是客户端的公钥，如果没有其他辅助信息，服务端无法判断收到的公钥是否属于客户端。

基于上述原因，客户端可以把**客户端基本信息（ClientBaseInfo，CBInfo）**和**CPubKey**一起发送给服务端，这样服务端就可以确认客户端公钥属于客户端。（为了方便描述，客户端基本信息和客户端公钥使用**CBInfo+CPubKey**表示）

### 2.黑客篡改CPubKey

但是，黑客可以拦截客户端发送的**CBInfo+CPubKey**，把**CPubKey**改成**HPubKey**，这样服务端就误以为收到的是客户端公钥，数据还是会泄漏。

解决数据被篡改的方法是使用hash算法生成摘要。hash算法有个特点是只要输入的数据有一点点变化，生成的摘要就会有很大的变化。

**hash( CBInfo + CPubKey ) = CSum**

使用hash算法将**CBInfo+CPubKey**生成一个**客户端摘要（ClientSummary，CSum）**，把**CSum**和**CBInfo+CPubKey**一起发送给服务端，服务端收到后也使用hash算法将**CBInfo+CPubKey**生成一个**CSum2**，对比**CSum**和**CSum2**是否一致就可以判断是否被修改。

### 3.黑客替换CBInfo+CPubKey

使用了hash摘要之后，虽然黑客修改不了**CBInfo+CPubKey**，但是黑客可以整个替换它。黑客使用hash算法将**CBInfo+HPubKey**生成一个**黑客摘要（HackerSummary，HSum）**，然后将**CBInfo+HPubKey**和**HSum**一起发送服务端，服务端还是会误以为收到的是客户端的公钥。

为了解决这个问题，我们只能依赖有公信力的**认证中心（Certificate Authoware，CA）**。

一般，服务端会向**CA**进行注册，注册内容包括**服务端基本信息（ServerBaseInfo，SBInfo）**和服务端公钥，**CA**使用hash算法将**SBInfo+SPubKey**生成一个**服务端摘要（ServerSummary，SSum）**，再使用**CA私钥（CAPrivateKey，CAPriKey）**加密**SSum**，生成一个**服务端数字签名（ServerDigitalSignature，SDSign）**，把**SDSign**给到服务端。**SBInfo+SPubKey**和**SDSign**加起来就是**服务端数字证书（ServerDigitalCertificate，SDCer）**。**CA公钥（CAPublicKey，CAPubKey）**通过其他手段给到客户端（比如，操作系统就只带CA的公钥）。

以后，客户端和服务端相互发送数据的时候，服务端先发送**SDCer**给客户端，客户端收到后，使用**CAPubKey**解密**SDCer**得到**SSum**，再使用hash算法将**SBInfo+SPubKey**生成一个**SSum2**，对比**SSum**和**SSum2**是否一致，就可以判断这个服务端公钥是否属于服务端。

### 4.通过数字签名的保护是否还存在中间人攻击的威胁？

数字签名是CA的私钥加密的，所以只有CA公钥能解密。CA公钥不通过网络方式发放，所以黑客替换不了CA公钥。基于上述两点，可以得出结论：只要是能被CA公钥解密的数字签名就是已经被CA认证过的。客户端使用hash算法将**SBInfo+SPubKey**生成一个**SSum**，使用**CAPubKey**解密**SDSign**生成一个**SSum2**，只要两个摘要对得上那数据就没有被修改过。如果黑客直接替换数字证书，那基本信息就会对不上。

所以，使用了数字签名可以解决中间人攻击的问题。

## 引用

https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA